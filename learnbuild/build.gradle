import javax.xml.transform.Source
import java.text.FieldPosition

/*task clean(type: Delete) {
    delete rootProject.buildDir
}*/

/*task hello << {
    println 'Hello world!'
}*/

task upper << {
    String someString = "mY_nAmE"
    println "Original:" + someString
    println "Upper case: " + someString.toUpperCase()
}

task count << {
    4.times { println "$it" }
}

/*task intro(dependsOn: hello) << {
    println "I'm Gradle"
}*/

task taskX(dependsOn: 'taskY') << {
    println('taskX')
}
task taskY << {
    println('taskY')
}

4.times { counter ->
    task "task$counter" << {
        println "I'm task number $counter"
    }
}

task0.dependsOn task2, task3

task hello << {
    println 'Hello Earth'
}

hello.doFirst {
    println 'Hello Venus'
}

hello.doLast {
    println 'Hello Mars'
}

hello << {
    println 'Hello Jupiter'
}

hello.doLast {
    println "Greetings from the $hello.name task."
}

task myTask {
    ext.myProperty = "myValue"
}

task printTaskProperties << {
    println myTask.myProperty
}

/*defaultTasks 'clean','run'
task clean <<{
    println 'Default Cleaning!'
}

task run <<{
    println "Default Running"
}
task other <<{
    println "I'm not a default task!"
}*/

defaultTasks 'myClean', 'myRun'
task myClean << {
    println 'Default Cleaning!'
}
task myRun << {
    println 'Default Running!'
}
task other << {
    println "I'm not a default task!"
}

task distribution << {
    println "We build the zip with version=$version"
}
task release(dependsOn: 'distribution') << {
    println 'We release now'
}

gradle.taskGraph.whenReady { taskGraph ->
    if (taskGraph.hasTask(release)) {
        version = '1.0'
    } else {
        version = '1.0-SNAPSHOT'
    }
}

apply plugin: 'java'

task compile << {
    println 'compiling source'
}
task compileTest(dependsOn: compile) << {
    println 'compiling unit tests'
}

task testOn(dependsOn: [compile, compileTest]) << {
    println 'running unit tests'
}

task dist(dependsOn: [compile, testOn]) << {
    println 'building the distribution'
}

task myhello << {
    println "using build file '$buildFile.name' in '$buildFile.parentFile.name'."
}

def dest = "dest"
task copy(type: Copy) {
    from "source"
    into dest
}

apply plugin: "java"

ext {
    springVersion = "3.1.0.RELEASE"
    emailNotification = "build@master.org"
}
sourceSets.all { ext.purpose = null }
sourceSets {
    main {
        purpose = "production"
    }
    test {
        purpose = "production"
    }
}
task printProperties << {
    println springVersion
    println emailNotification
    sourceSets.matching {
        it.purpose == "production"
    }.each {
        println it.name
    }
    println project.buildDir
    println getProject().getBuildDir()
    test.systemProperty 'some.prop', 'value'
    repositories {
        println "in a closure"
    }
    repositories() { println "in a closure" }
    repositories({ println "in a closure" })
}

test.includes = ['org/gradle/api/**', 'org/gradle/internal/**']
List<String> list = new ArrayList<String>()
list.add('org/gradle/api/**')
list.add('org/gradle/internal/**')
test.includes = list
// Map literal
apply plugin: 'java'
Map<String, String> map = new HashMap<String, String>()
map.put('plugin', 'java')
apply(map)

File classesDir = new File('build/classes')
task resources << {
    classesDir.mkdirs()
}

task mycompile(dependsOn: 'resources') << {
    if (classesDir.isDirectory()) {
        println 'The class directory exists. I can operate'
    }
}

task printProps << {
    println commandLineProjectProp
    println gradlePropertiesProp
    println systemProjectProp
    println envProjectProp
    println System.properties['system']
}

//apply from: 'other.gradle'

task configure << {
    FieldPosition pos = configure(new java.text.FieldPosition(10)) {
        beginIndex = 1
        endIndex = 5
    }
    println pos.beginIndex
    println pos.endIndex
}

task myConfigure << {
    FieldPosition pos = new java.text.FieldPosition(10)
    apply from: 'other.gradle', to: pos
    println pos.beginIndex
    println pos.endIndex
}

task(yourHello) << {
    println "yourHello"
}

task(mycopy, type: Copy) {
    from(file('srcDir'))
    into(buildDir)
}

task('learnhello') << {
    println "learnhello"
    println learnhello.name
    println project.learnhello.name
    println tasks.learnhello.name
    println tasks['learnhello'].name
    println
}

tasks.create(name: 'thishello') << {
    println "thishello"
}
/*project(':other') {
    task otherHello
}*/
task ham << {
    println tasks.getByPath('ham').path
    println project.name
}

//task myCopy(type: Copy)

Copy myCopy = task(myCopy, type: Copy)
myCopy.from 'resources'
myCopy.into 'target'

myCopy.include('**/*.txt', '**/*.xml', '**/*.properties')

task taskC << {
    println 'taskC'
}
task taskD << {
    println 'taskD'
}
//taskD.mustRunAfter taskC
taskD.shouldRunAfter taskC

task yourcopy(type: Copy)
task yourcopy(overwrite: true) << {
    println('I am the new one.')
}

task helloHi << {
    println 'hello world'
}
helloHi.onlyIf {
    !project.hasProperty('skipHello')
}

task yourcompile << {
    println 'We are doing the compile.'
}
compile.doFirst {
    // Here you would put arbitrary conditions in real life. But we use this as an integration test, so we want defined behavior.
    if (true) {
        throw new StopExecutionException()
    }
}
task yourTask(dependsOn: 'yourcompile') << {
    println 'I am not affected'
}

task disableMe << {
    println 'This should not be printed if the task is disabled.'
}

disableMe.enabled = false

task taskE << {
    println 'taskE'
    throw new RuntimeException()
}
task taskF << {
    println 'taskF'
}
taskE.finalizedBy taskF

tasks.addRule("Pattern: ping<ID>") { String taskName ->
    if (taskName.startsWith("ping")) {
        task(taskName) << {
            println "Pinging: " + (taskName - 'ping')
        }
    }
}
task groupPing {
    dependsOn pingServer1, pingServer2
}
// Using a relative path
File configFile = file('src/config.xml')
// Using an absolute path
configFile = file(configFile.absolutePath)
// Using a File object with a relative path
configFile = file(new File('src/config.xml'))

//Project.files()

FileCollection collection = files('src/file1.txt', new File('src/file2.txt'), ['src/file3.txt', 'src/file4.txt'])

task printlncollection << {
    collection.each { File file ->
        println file.name
    }
    Set set = collection.files
    Set set2 = collection as Set
    List list1 = collection as List
    String path = collection.asPath
//    File file1 = collection.singleFile
//    File file2 = collection as File
    def union = collection + files('src/file3.txt')
    def different = collection - files('src/files.txt')
    println 'union ' + union.
            println 'different ' +different
}

task list << {
//    File srcDir=file('learnbuild/5.txt')
    File srcDir
    collection = files { srcDir.listFiles() }
    srcDir = file('src')
    println srcDir.name
    collection.collect { relativePath(it) }.sort().each { println it }
    println collection
}
//compileJava.destinationDir = file("$buildDir/output/classes")
//sourceSets.main.output.classesDir=file("$buildDir/output/classes")

task show << {
    println relativePath(compileJava.destinationDir)
    println relativePath(processResources.destinationDir)
}

// Create a file tree with a base directory
FileTree tree = fileTree(dir: 'src/main')
// Add include and exclude patterns to the tree
tree.include '**/*.java'
tree.exclude '**/Abstract*'
// Create a tree using path
tree = fileTree('src').include('**/*.java')
// Create a tree using closure
tree = fileTree('src') {
    include '**/*.java'
}
// Create a tree using a map
tree = fileTree(dir: 'src', include: '**/*.java')
tree = fileTree(dir: 'src', includes: ['**/*.java', '**/*.xml'])
tree = fileTree(dir: 'src', include: '**/*.java', exclude: '**/*test*/**')

// Iterate over the contents of a tree
task myTree << {
    println "myfile"
    tree.each { File file ->
        println "myfile"
        println 'file' + file
    }
}
// Filter a tree
FileTree filtered = tree.matching {
    include 'org/gradle/api/**'
}
// Add trees together
FileTree sum = tree + fileTree(dir: 'src/test')
// Visit the elements of the tree
tree.visit { element ->
    println "$element.relativePath => $element.file"
}

task yourTree << {
    tree.visit { element ->
        println "$element.relativePath => $element.file"
    }
    println "myfile"
    tree.each { File file ->
        println "myfile"
        println 'file' + file
    }
}
/*compile {
    source  = file('src/main/java')
}*/
task printSource << {
    println source
}

task rename(type: Copy) {
    from 'src/main/'
    into 'src/build/'
    // Use a closure to map the file name
    rename { String fileName ->
        fileName.replace('ha.py', 'su.py')
    }
    // Use a regular expression to map the file name
    /* rename '(.+)-staging-(.+)', '$1$2'
     rename(/(.+)-staging-(.+)/, '$1$2')*/
}

task libs(type: Sync) {
    from 'src/main/'
    into 'src/build/'
}

task zip(type: Zip) {
    from 'src/main'
    into('src/build') {
        from configurations.runtime
    }
}

version = 1.0
/*task myZip(type: Zip) << {
    from 'somedir'
//    println "myZip.archiveName" + myZip.archiveName
}*/
//println myZip.archiveName

//apply plugin: 'java'
version = 1.0
task myZip(type: Zip) << {
    from 'somedir'
    println myZip.archiveName
}
println myZip.archiveName
println relativePath(myZip.destinationDir)
println relativePath(myZip.archivePath)


archivesBaseName = 'gradle'
version = 1.0
task yourZip(type: Zip) << {
    appendix = 'wrapper'
    classifier = 'src'
    from 'somedir'
    println yourZip.archiveName
}
sourceSets {
    intTest
}
task intTestJar(type: Jar) {
    from sourceSets.intTest.output
}
task intTestJavadoc(type: Javadoc) <<{
    source sourceSets.intTest.allJava
    println sourceSets.intTest.allJava+"aaa"
}